# 回溯

## 子集型回溯（2026-1-6）

基础题目：17.电话号码的字母组合、78.子集、131.分割回文串

扩展题目：257、113、784

### 概述

什么是回溯？从例子中体会，来看找集合（1，2，3）的子集的问题：我选择了元素1，还可以选择元素2、3；但是我也可以退回去不选元素1，选择元素2，再选择元素3 ，这个现象就是回溯。

简单来说，就是构造答案的过程中，回退到上一步的过程。它通常有两种实现形式：循环与递归。循环的表达能力有限，简单的一两层嵌套也可以实现回溯，但是如果循环层数未知或者层数过多，循环就无法实现了，所以回溯通常伴随递归而不是循环。

从递归的角度看回溯：考虑深度遍历一棵树，通过遍历获取路径（路径指根到叶子节点上节点），我们需要维护一个 path 记录当前路径，当当前节点是叶子节点时，将 path 添加到答案中。这个过程能很好的体会回溯：在我们到达叶子节点后，需要往回退到父节点，去找其他可能的路径，这个回退就可以理解为回溯。

回溯的过程往往伴随恢复现场：怎么理解这个恢复现场，还是获取树路径的例子，在记录的当前 path 路径当中，到达叶子节点添加答案后，要将该叶子节点从路径中删除，否则达不到回退的效果。而恢复现场有两种方式：数据覆盖、回滚上一次添加的数据。数据覆盖通常用于数组，也就是答案长度固定的情况；回滚操作则常用于集合，利用 removeLast() 方法删除最新添加的。

### 心得体会

* 回溯题型通常有两种思路：
  * 从输入的角度：枚举到的当前元素选不选
  * 从构建答案的角度：第一个答案元素选哪个
* 回溯通常有套路，一个是记录答案 ans，一个是记录的路径 path，当路径 path 满足答案的条件时，将 path 加入到答案中，这通常就是递归的边界。
* 对于回溯的两个思路：枚举当前元素选不选通常答案出现在叶子节点中；而对于当前答案选哪个通常答案是树的节点。两者各有千秋，有的题枚举当前答案选哪个树的节点少一些，有的题枚举当前元素选不选思路更清晰。
* 还有个套路就是：遍历到当前节点时，如果将当前节点加入了 path，则往下递归遍历后需要将当前节点删除 path
* **思路不明确时，可以通过画树来解决**，因为通过画树能很好的体会到回溯的过程，以及什么地方需要回溯，什么地方才可以记录答案。
* 用到了 String.join（）新的 API，它可以连接多个字符并指定连接符号，类似 StringBuild 与 StringJoin

### 结合具体题目

例如，78 子集问题的两个思路解题：

* 枚举输入的元素选不选：

```java
dfs(int i, int[] nums, List<Integer>path, List<List<Integer>> ans){
    // 表示输入的元素枚举完了，每一种可能都考虑到了
    if (i == nums.length) {
            ans.add(new ArrayList<>(path));
            return;
    }
    //不选，直接枚举下一个元素
    dfs(i + 1, nums, path, ans);
    
    // 选，将当前元素加入 path
    path.add(nums[i]);
    // 枚举下一个元素
    dfs(i + 1, nums, path, ans);
    // 恢复现场
    path.removeLast();
}
```

* 枚举第i个答案选哪个元素（树的每个节点都是答案）：

```java
 private void dfs(int i, int[] nums, List<List<Integer>> ans, List<Integer> path) {
    // 由于树的每个节点都是答案，所以遍历到当前节点直接记录答案
    ans.add(new ArrayList<>(path));
     // 枚举第 i 个答案选第 j 个元素，由于(1,2)与(2,1)算重复的子集，所以我们可以规定枚举的顺序，
     // 枚举的下一个下标一定大于当前下标，这样就实现了去重，
     // 例如，枚举了[1,2]，在枚举[2]时，就只能枚举[2,3]
     // 这里的体现就是每次 j 从 i开始枚举而不从头开始枚举
    for (int j = i; j < nums.length; j++) {
        // 第 i 个答案选第 j 个元素
        path.add(nums[j]);
        // 遍历第 i+1 个答案
        dfs(j+ 1, nums, ans, path);
        // 回滚
        path.removeLast();
   }
 }
```

## 子集型回溯（2026-1-8）

基础题目：17.电话号码的字母组合、78.子集、131.分割回文串

扩展题目：LCP51、2397、1239、2212、2698、93

通过之前总结的子集型回溯的方法论，解决了上述 6 道扩展题目。

结合具体题目：

LCP51.烹饪料理：枚举第 i 种料理选或者不选，其中选是有条件的，即材料够用

2397.被列覆盖的最多行数：同样可以枚举矩阵种第 i 列选或者不选，其中选也是有条件的，选的话选择的总列数不能超过 numSelect，其中当剩下的列数小于等于 numSelect 时，就必须全选了

1239.串联字符串的最大长度：同样思路也是枚举每个字符串选还是不选，同样也是有条件的选，选的字符串必须在之前的字符串中没有出现，同时选的字符串中不能含相同的字母

2212.射箭比赛中的最大得分：枚举每个得分区域，如果选择在该得分区域得分，就需要射中得数量大于 alice 以及剩余得箭得数量有这么多

2698.求一个整数得惩罚数：这道题就是需要用回溯来判断一个数得平方是否可以拆分为和为该数，可以就加入答案，所以本质上是字符串分割问题。

93.复原 IP 地址：这道题也是带条件得字符串分割问题，需要注意得就是其中有一个隐含条件，必须分割为 4 段



### 心得体会

子集型回溯其实是一种暴力解决方法，通过枚举输入集合中得每个元素是否加入当前轮得子集，加入需要满足一定条件，当所有元素都枚举完毕后，得到得当前轮得子集就是潜在答案。为什么可以做到不重不漏？因为每个元素本质上就只有选或者不选两个可能，通过递归回溯实现遍历每种可能，所以通常时间复杂度为 O（2^n）n为输入元素得个数。

带条件得子集型回溯就是在选择当前元素加入子集时，需要判断是否满足题目得要求，可以把这部分逻辑抽离成一个 check 函数，这样就不会在 dfs 时很复杂。

子集型回溯得优化，通常是提前判断继续向下遍历也不会有符合题意得答案，来实现剪枝。

## 组合型回溯+剪枝（2026-1-9）

基础题目：77.组合、216.组合总和、22.括号生成

扩展题目：39.组合总和、93.复原 IP 地址

### 概述

组合型回溯是在子集型问题的基础上，筛选出一组满足条件的组合，例如选长度为 2 的子集，或者集合中的元素和为 target 的组合，这也是为什么今天的专题是组合型回溯 + 剪枝，因为要通过子集的组合条件来对搜索树进行剪枝。

### 结合具体题目

77.组合：两个剪枝：倒着遍历，当满足数目要求时，直接返回，不用向下遍历；当剩余元素个数，小于需要加入子集的元素个数，直接返回不需要遍历。

216.组合总和 Ⅲ：两个剪枝：leftTarget<0 时直接返回（元素必然大于0），leftTarget> 剩下要选的数的最大和，也直接返回（一大一小体现对称性）；当剩余元素个数，小于需要加入子集的元素个数，直接返回不需要遍历

22.括号生成：这道题用选或不选的思想要简单些，选相当于添加左括号，不选相当于添加右括号。添加左括号只要不超过 n 都可以添加，而添加右括号需要左括号数量大于右括号。所以这道题本质上是一个带条件的组合型回溯

39.组合总和：这道题的要点就是可以重复选择元素，由于集合中的元素值大于1，所以当 leftTarget <0 时，剪枝；同时，leftTarget = 0 时记录答案剪枝。选与不选中，选的话通过 dfs(i) 表达可以重复选择；枚举选哪个中，通过 dfs(j) j为当前枚举选的元素，来表达重复选择。还有一个剪枝技巧：将原数组排序，这样枚举到当前元素大于 leftTarget 时可以进行剪枝。

93.复原 IP 地址：由于限制条件比较多，能够剪枝的情况也比较多：首先由于必须分割为 4 段，每段至少一个字符，至多 3 个字符，所以剩余字符数量在这个区间外，直接剪枝；当前分割的字符串的值大于 255 直接剪枝，当前分割的字符串是 0 开始的直接剪枝。由于知道分割次数，所以这道题也可以用三重循环来做（分割为 4 段）

### 心得体会

其实，组合型回溯就是子集型回溯，只不过在满足组合要求的条件下对子集型回溯进行剪枝，相当于子集型回溯是罗列全部情况，组合型只需要罗列满足条件的情况，当前节点不满足条件，往下搜索更不会满足条件，所以这里面存在一种”单调性“。实际做题中，可以先完成题目要求，再看搜索的过程能否提前返回，这样比一开始将答案逻辑与剪枝逻辑混合写要简单些。
