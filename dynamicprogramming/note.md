# 动态规划

## 从回溯到记忆化搜索到递推（2026-1-11）

基础题目：198.打家劫舍

扩展题目：70.爬楼梯、746.使用最小花费爬楼梯、3693.爬楼梯Ⅱ、213.打家劫舍Ⅱ

### 概述

什么是动态规划？从回溯到记忆化搜索再到递推来探索这个问题的答案。

从打家劫舍的例子中体会这个逐步递进的过程：首先从最后一个元素开始枚举（方便后面衔接动态规划），有选或不选两个选择，`dfs（i）`表示前 i 个元素的最大金额，则 `dfs（i） = Math.max(dfs(i - 1), dfs(i - 2) + nums[i])` 。但是这样会有大量重复计算，如图 `dfs(2)`计算了两次，`dfs(1)`计算了三次

![1](assets/1.png)

记忆化搜索：优化回溯的计算过程，将之前计算过的返回值 dfs(i) 保存，每次递归计算前判断之前是否计算过，计算过直接返回结果。

```java
private int dfs(int i, int[] nums, int[] cache) {
        if (i < 0) {
            return 0;
       }
        if (cache[i] != -1)
          return cache[i];
       cache[i] = Math.max(dfs(i - 1, nums, cache), dfs(i - 2, nums, cache) + nums[i]);
       return cache[i];
   }
```

递推：记忆化搜索用到了递归以及额外的空间保存 `dfs(i)` 的结果，能否对空间复杂度进行优化？答案是可以的，在递归遍历树的时候，我们清楚的知道节点 2 的返回值，也就是 `dfs(2)` 来自 `dfs(1)`与`dfs(0)`，同样`dfs(3)` 来自 `dfs(2)`与`dfs(1)`，所以可以直接从自顶向上转变为自底向上的递推，简单说，就是先计算  `dfs(1)`与`dfs(0)`，然后递推到 `dfs(2)`，以此类推计算到 `dfs(i)`，怎么理解这里的递推？其实就是 `dfs`时省略的递的过程，直接归。这样做的好处是：将递归转化为循环，避免了递归栈的额外空间开销。

从记忆化搜索到递推：

* 状态数组（dp 数组）记录 dfs 的返回结果
* 循环代替递归
* 状态数组的初始化代替递归边界条件

回过来看怎么理解递推？就是从先前的状态递推到下一个状态，当前状态不仅仅与当前元素有关，还与之前的元素有关，因为当前状态来自与之前的状态，而之前状态受之前元素的影响。以打家劫舍为例，打劫第 2 个房子后的最大金额 由 打劫第 1 个房子后的最大金额 与 打劫第 0 个房子后的最大金额决定，这就是递推公式。这个例子中由于当前状态只需要之前的两个状态，所以可以进一步将空间复杂度优化为 O（1）



### 结合具体题目

70.爬楼梯：爬到当前 i 阶的爬法，由 i-1阶的爬法 + i-2阶的爬法决定，这个就是递推公式，状态的初始化第一阶有一种爬法，第零阶也有一种爬法（或者第二阶有两种爬法），循环需要遍历 n 个状态，最终返回状态 n

746.使用最小花费爬楼梯：由题意花费 cost[i] 可以选择向上爬一或两个台阶，所以当前状态由前一个状态和前前状态决定，递推公式得到了，状态的初始化可以从 0 阶或 1 阶开始，前两个状态为 0，需要遍历 n 个状态，最终返回状态 n

3693.爬楼梯 Ⅱ：就是爬楼梯的变形，由题意一次可以跳 1、2、3 阶台阶，所以当前状态是由前三个状态决定的

213.打家劫舍 Ⅱ：同样，也是打家劫舍的变形




### 心得体会

* 动态规划体现了 dfs 中的归，省略递的过程直接归，将其转化为递推，当前状态由之前的状态决定，这就体现了动态，即状态是变化的。
* 当递推关系或者初始状态想不清楚时，可以回到回溯+记忆化搜索，再将其翻译为递推。
* 解题时，当题目中的当前状态受之前状态的影响，准确的说当前状态是在之前状态的基础上得来，就可以使用动态规划。

## 从回溯到记忆化搜索到递推巩固练习（2026-1-12）

基础题目：198.打家劫舍

扩展题目：740.删除并获得点数、2466.统计构造好字符串的方案数、377.组合总和、2266.统计打字方案数、64.最小路径和

### 概述

今天的题目是打家劫舍、爬楼梯这些基础题型的变形题，通过今天的学习对打家劫舍与爬楼梯这类题有了更深刻的体会。

### 结合具体题目

740.删除并获得点数：每次操作选择任意一个 nums[i] 将它与所有nums[i]+-1一同删除，并获得 nums[i]的点数，返回最大点数。这道题是打家劫舍的变形：考虑将所有值相同的 nums[i] 归为一类，也就是创建一个值域数组 sums，sums[j] 表示在 nums 中所有值 j 的数的和，例如 nums = [2,2,3,3,3,4], sums=[0,0,4,9,4]，现在就相当于在 sums 中选择一个元素，相邻元素就不能选择了，转化为了打家劫舍。

2466.统计构造好字符串的方案数：这道题其实是爬楼梯的变形题，每次可以爬 zero 或 one 阶，求爬 low 到 high 阶楼梯的方案总数

377.组合总和Ⅳ：给你一个由不同整数组成的数组 nums ，和一个目标整数 target 。请你从 nums 中找出并返回总和为 target 的元素组合的个数（不同顺序算不同的组合）。本质也是爬楼梯，相当于爬 target 阶，每次可以上 nums[i] 阶楼梯，求方案数。

2266.统计打字方案数：题目较为复杂，就不叙述了，可以在 leetcode 上参考原题。本质上是分组+爬楼梯，按照不同 target 分组，最后的方案数是各组的方案数相乘。

 64.最小路径和：这道题不是变形题，它是动归经典题型，当前状态取决于左状态与上状态。

### 心得体会

打家劫舍本质在于约束条件是选了一个元素，其相邻元素都不可以选了。 740.删除并获得节点数，选择一个节点，删除该节点值相邻的元素，所以联想到打家劫舍，没有打家劫舍的条件，就构造打家劫舍的条件：值域数组。

爬楼梯的本质是一个排列问题，也就是顺序不同属于不同的方案，例如先迈1步再迈2步与先迈2步再迈1步是不同的，这让爬楼梯适配很多题型：字符串长度一定、和一定，这种定值可以看作目标台阶数量 target，而每次可以选择不同数量的元素来构造答案，相当于一次可以选择爬不同数量的阶梯数。

## DP 模型：0-1背包与完全背包（2026-1-13）

基础题目：494.目标和、322.零钱兑换

扩展题目：2915.和为目标值的最长子序列的长度

### 概述

0-1背包与完全背包是枚举输入元素选或不选的代表。

**0-1 背包**：有 n 个物品，第 i 个物品的体积为 w[i]，价值为 v[i]，每个物品最多选一个，求体积和不超过 capacity 时的最大价值和。

#### 回溯三问

* 当前操作：枚举第 i 个物品选或不选：不选，剩余容量不变；选，容量减少 w[i]
* 子问题：剩余容量为 c 时，前 i 个物品中的最大价值和
* 下一个子问题：分类讨论：
  * 当前操作不选：剩余容量 c 从前 i-1 个物品中得到的最大价值
  * 当前操作选：剩余容量 c - w[i] 从前 i-1 个物品得到的最大价值

```java
int dfs(int i, int c, int[] w, int[]v){
	if(i<0)
        return 0;
    if(w[i] > c)
        dfs(i-1,c,w,v);  // 容量不够，不能选当前元素
    return Math.max(dfs(i-1,c,w,v),dfs(i-1,c-w[i],w,v)+v[i]);
}
```

**完全背包**：有 n 种物品，第 i 种物品的体积为 w[i]，价值为 v[i]，每种物品可以重复选，求体积和不超过 capacity 时的最大价值和。

就是 0-1 背包下添加了可以重复选物品条件，体现在递归时，选了当前第 i 种物品，还可以选第 i 种物品：如表达式1：`dfs(i,c) = Math.max(dfs(i-1,c), dfs(i,c-w[i])+v[i]);` 

> 为什么不需要写 *dfs*(*i*−1,*c*−*coins*[*i*]) 呢？选了一个就不再选了，这样不行吗？
>
> 其实表达式 1 已经考虑这种情况了，先「选一个」，递归到 dfs(i,c−w[i])，在这个递归中再「不选」，就能递归到 dfs(i−1,c−coins[i]) 了。也就是说，递归两次，我们就能表达出「选了一个就不再选」的逻辑。从这个例子，体会递归所蕴含的强大表达能力。

#### 常见变形

* 至多装 capacity，求方案数/最大价值和
* 恰好装 capacity，求方案数/最小价值和/最大价值和
* 至少装 capacity，求方案数/最小价值和

### 结合具体题目

494.目标和：这道题可以转化为恰好为 target，求方案数的 0-1背包模型。这是我的解题步骤：首先用回溯+记忆化搜索解决了题目，再翻译为递推，再进一步优化空间复杂度。

* 枚举每个数，都有选或不选
* 子问题 i 以前的元素和为 target 的方案数
* 下一个子问题：dfs(i,t) =  dfs(i,t-nums[i]) + (dfs,t)

对于当前元素，选是有条件的，必须剩余容量要大于当前物品的体积，具体而言也就是 target 要大于当前数的数值。

322.零钱兑换：这道题是完全背包的的恰好为 capacity 求最小价值的变形。amount 对应 capacity，每个硬币的价值视为1，数组 coins[i] 则对应物品体积。

2915.和为目标值的最长子序列的长度：这道题则是0-1背包的恰好为 target 求最大价值和的变形。每个数组元素对应的价值为1，nums[i] 对应物品的体积

### 心得体会

做了这几道题下来，我感觉到 DP 题目的关键在状态数组的转移方程以及状态数组的初始化，而要想写出这两个东西，要理解状态数组的含义即 `dp[i][j]` 表达的是什么意思。上面的三道题题，我们是从回溯的角度 `dfs(i,j)` 来体会返回值也就是归表达的含义中体会到了 `dp[i][j]`  的含义，即 `dp[i][j]` 表示前 i 个数中，和为 j 的方案数/价值和。希望后续熟练以后，可以直接写出动态规划的题解，而不是首先用回溯+记忆化搜索解决了题目，再翻译为递推，再进一步优化。

在对动态规划进行空间复杂度上的优化时，需要注意当前状态的更新用到了之前的哪些状态，这三道题都是当前状态的更新只用到了前一个状态（这对 i 来说），`dp[i + 1][j] = dp[i][j] + dp[i][j - nums[i]]` 或 `dp[i + 1][j] = Math.min(dp[i + 1][j - coins[i]] + 1, dp[i][j]);` 所以肯定可以采用覆盖的方式将`dp[n][target+1]` 优化为 `dp[2][target+1]`，更进一步还可以将二维数组优化为一维，这需要看当前状态是否依赖于没有旧的之前的状态，`dp[i][j - nums[i]]` 就是需要旧的之前的状态，而`dp[i + 1][j - coins[i]]` 则是依赖于新的之前的状态，这里的新旧是针对 i 与 i+1，而言的，总之，空间的优化属于锦上添花，如果实在想不清楚，可以忽略。

## DP 模型：0-1背包与完全背包变形题（2026-1-14）

基础题目：494.目标和、322.零钱兑换

扩展题目：416.分割等和子集、2787.将一个数字表示成幂的和的方案数、518.零钱兑换Ⅱ、279.完全平方数

### 结合具体题目

416.分割等和子集：该问题可以转化为01背包问题，分为两个和相等的子集，等价于是否存在一个子集和为总和的一半。所以 capacity = sum/2，体积为 nums，求是否存在恰好为 capacity 的方案。这道题有个小 trick，如果在递推过程中，出现了 dp[target] = true，也就是存在这样的方案，就可以直接返回 true，递推过程中没有出现，则返回 false表示不存在这样的方案。

2787.将一个数字表示成幂的和的方案数：这道题也是01背包问题，n 等价于背包容量，1^x，2^x... 是物品的体积，求恰好为 n 时的方案数

518.零钱兑换Ⅱ：完全背包的变形，基础题型零钱兑换（求最少硬币数）的变形，这道题求得是方案数，amount 等价于背包容量，coins 等价于物体体积，每个硬币的数量等价于价值为 1

279.完全平方数：n 等价于容量，平方数等价于物体体积，求体积和恰好为 n 的最少数量

### 心得体会

逐步能跳过回溯直接写动态规划数组的递推公式了，这些题本质上都是选与不选结合求和，比较好理解`dp[i][j]` 的含义。

完全背包与01背包还是很好区分的，只用看选过的元素能否再选即可。

## 线性 DP （2016-1-15）

基础题目：1143.最长公共子序列、72.编辑距离

扩展题目：583.两个字符串的删除操作

### 概述

怎么理解这个线性DP？可以从三个角度来理解：

* 当前状态是由过去递推过来的
* 最终可以优化为一维数组
* 从一维数组来看遍历顺序也是线性的（二维数组的遍历顺序也是线性的，先固定一个维度，再一次遍历）

所以 **01背包** 与 **完全背包** 模型都属于线性 DP，思考：它们与今天的题型有什么不同，又有什么相同？

### 结合具体题目

1143.最长公共子序列：考虑枚举两个字符串，i、j 分别表示第 i、j 个字符，回溯思想：

* 当前操作：i、j 选还是不选（也就是是否加入公共子序列当中）
* 子问题：前 i、j 个字符的最长公共子序列
* 下一个子问题：前 i-1、j-1 个字符的最长公共子序列

注意这里返回值的含义（与后面 dp 数组的含义相关）：dfs(i,j) 表示前 i 个字符与前 j 个字符的最长公共子序列。从递推的角度，两个字符串都从 0 开始枚举，`dp[i][j]` 表示前 i 个字符与前 j 个字符的最长公共子序列，对于当前状态，如果当前枚举的字符相等，自然子序列长度 + 1；如果不等，那么当前状态应该来自于前面状态的最大值，即 `max(dp[i-1][j],dp[i][j-1])`。

72.编辑距离：怎么把这道题与1143联系起来？都是对两个字符串操作，将word1转换成word2，也可以理解为相同的部分不变，不同的部分删除、替换、插入。考虑删除、替换、插入操作是对枚举的 i 字符进行操作，删除就对应 i-1，插入的话对应 j-1，替换就是 i、j 同时减一，比较抽象，需要理解，建立联系后就比较简单了。

583.两个字符串的删除操作：这道题就是编辑距离的特殊情况，只能进行删除操作，但是可以对两个字符串进行删除操作，理解了编辑距离，就很好解决这道题了。

### 心得体会

背包问题与今天的题目主要区别在于背包问题输入的是数组，今天的公共子序列系列问题输入的是字符串，dp 数组的含义也不同，背包问题 `dp[i][j]` 表示前 i 个数中和为 j 的方案数/价值和；字符串问题的 `dp[i][j]` 表示前 i 个字符与 前 j 个字符的公共子序列/变为相同的操作数。今天的题目有一个共同点就是判断当前字符是否相同，相同与不相同的操作不同。

总之今天做了字符串相关的线性 DP 问题，明天继续巩固。

