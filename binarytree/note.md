# 二叉树

## 递归二叉树（2025-12-31）

* 递归：将原问题不断分为子问题，体现了递，这样不断划分下去，总有一个尽头，这个尽头就是边界条件，在达到边界条件后，返回结果的过程体现了归。
* 二叉树的递归遍历，一开始不要陷入细节，而是考虑整个树和左右子树的关系，抓住递；然后再考虑递的尽头，边界条件，以及达到边界条件后返回结果的归的过程。
* 答案通常就在二叉树递的过程或者归的过程产生（一些题目提供了两种解法）。
* 二叉树最小深度于最大深度的区别在于：对于**非叶节点**，如果一个儿子是空节点，另一个儿子不是空节点，那么**答案只能来自非空的那一侧**。而最大深度的逻辑一定会选非空一侧，而最小深度则会选空一侧，所以要通过代码逻辑来避免这种情况。
* 将二叉树的递归遍历解题步骤通常划分为：递、归、记录答案，三个过程。
* 如果判断当前节点是否符合答案的逻辑时，需要用到父节点的信息，这个信息可以从全局变量获取，也可以在递的过程传递下来。
* 在二叉树的垂序遍历过程中，用到了map相关知识点，这里总结复习一下：
  * 要想 map 的按键排序，用实现类 treemap
  * 对于集合指定规则的排序用 comparator 比较器中指定
  * map.computeIfAbsent 的用法：如果 key 存在，直接返回value，否则传入key，计算返回 value 最终返回 value

## 二叉树 相同、对称、平衡、右视图（2026-1-1）

基础题目：100.相同的树、101.对称二叉树、110.平衡二叉树、119.二叉树的右视图

扩展题目：965、954、226、617、2331、508、1026、1372、1080

心得体会：
* 首先今天最强烈的感觉就是二叉树的递归遍历本质上是访问每一个节点，在访问的过程中对节点做处理，而子问题的拆分，其实是在提取公共逻辑部分的代码。
* 在访问当前节点的方法中调用自身来访问子节点，就能实现递归遍历，而且这种遍历没有遗漏
* 有时题目比较复杂，可以将递归遍历中的逻辑简化，通过返回值、全局变量记录必要的数据，递归结束后再处理答案的逻辑。
* 复习了 map.merge 的用法：key 不存在直接建立 （key，newValue），key 存在，将 oldValue 与 newValue 一同传入函数，返回值作为新值
* 在 1026.节点与其祖先之间的最大差值一题中体会到了自顶向下的递与自底向上的归的过程。
* 加深了我对“递”与“归”的理解：递是一个分解问题的过程，归是更关注整体的关系
* 自顶向下：有点类似先序遍历，先对当前节点做逻辑处理，再向下传递
* 自底向上：则类似后序遍历，先到最下面，再向上归，再根据左子树的情况和右子树的情况得到本树的情况
* 具体选用哪种方法，我认为要看你的答案怎么产生，或者说需要什么信息，如果需要向下传递的信息，例如路径和，直观的方法就是向下传递，但是也可以向上归时减去当前节点的值，也能实现。但是有的信息则需要特定的其中一种，又或者将两者结合，这就是难题了。
* 自顶向下更符合人类思维，但若要学好后面的动态规划，必须掌握自底向上的思考方式。
* 1372.二叉树中的最长交错路径让我体会到了递归过程重置变量
* 递归只有在处理（递下去）的问题时，才可以转化为迭代。处理（归上来）问题时，是无法转化为迭代的。
* 1080. 根到叶路径上的不足节点题中我充分体会到了递与归，首先递的是从上到该节点的路径和，归的是包含该节点的从根到叶的路径总和，将这两个信息都记录下来，中间的逻辑就是判断该节点是否是不足节点需要删除的逻辑了。

