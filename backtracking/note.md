# 回溯

## 子集型回溯（2026-1-6）

基础题目：17.电话号码的字母组合、78.子集、131.分割回文串

扩展题目：257、113、784

### 概述

什么是回溯？从例子中体会，来看找集合（1，2，3）的子集的问题：我选择了元素1，还可以选择元素2、3；但是我也可以退回去不选元素1，选择元素2，再选择元素3 ，这个现象就是回溯。

简单来说，就是构造答案的过程中，回退到上一步的过程。它通常有两种实现形式：循环与递归。循环的表达能力有限，简单的一两层嵌套也可以实现回溯，但是如果循环层数未知或者层数过多，循环就无法实现了，所以回溯通常伴随递归而不是循环。

从递归的角度看回溯：考虑深度遍历一棵树，通过遍历获取路径（路径指根到叶子节点上节点），我们需要维护一个 path 记录当前路径，当当前节点是叶子节点时，将 path 添加到答案中。这个过程能很好的体会回溯：在我们到达叶子节点后，需要往回退到父节点，去找其他可能的路径，这个回退就可以理解为回溯。

回溯的过程往往伴随恢复现场：怎么理解这个恢复现场，还是获取树路径的例子，在记录的当前 path 路径当中，到达叶子节点添加答案后，要将该叶子节点从路径中删除，否则达不到回退的效果。而恢复现场有两种方式：数据覆盖、回滚上一次添加的数据。数据覆盖通常用于数组，也就是答案长度固定的情况；回滚操作则常用于集合，利用 removeLast() 方法删除最新添加的。

### 心得体会

* 回溯题型通常有两种思路：
  * 从输入的角度：枚举到的当前元素选不选
  * 从构建答案的角度：第一个答案元素选哪个
* 回溯通常有套路，一个是记录答案 ans，一个是记录的路径 path，当路径 path 满足答案的条件时，将 path 加入到答案中，这通常就是递归的边界。
* 对于回溯的两个思路：枚举当前元素选不选通常答案出现在叶子节点中；而对于当前答案选哪个通常答案是树的节点。两者各有千秋，有的题枚举当前答案选哪个树的节点少一些，有的题枚举当前元素选不选思路更清晰。
* 还有个套路就是：遍历到当前节点时，如果将当前节点加入了 path，则往下递归遍历后需要将当前节点删除 path
* **思路不明确时，可以通过画树来解决**，因为通过画树能很好的体会到回溯的过程，以及什么地方需要回溯，什么地方才可以记录答案。
* 用到了 String.join（）新的 API，它可以连接多个字符并指定连接符号，类似 StringBuild 与 StringJoin

### 结合具体题目

例如，78 子集问题的两个思路解题：

* 枚举输入的元素选不选：

```java
dfs(int i, int[] nums, List<Integer>path, List<List<Integer>> ans){
    // 表示输入的元素枚举完了，每一种可能都考虑到了
    if (i == nums.length) {
            ans.add(new ArrayList<>(path));
            return;
    }
    //不选，直接枚举下一个元素
    dfs(i + 1, nums, path, ans);
    
    // 选，将当前元素加入 path
    path.add(nums[i]);
    // 枚举下一个元素
    dfs(i + 1, nums, path, ans);
    // 恢复现场
    path.removeLast();
}
```

* 枚举第i个答案选哪个元素（树的每个节点都是答案）：

```java
 private void dfs(int i, int[] nums, List<List<Integer>> ans, List<Integer> path) {
    // 由于树的每个节点都是答案，所以遍历到当前节点直接记录答案
    ans.add(new ArrayList<>(path));
     // 枚举第 i 个答案选第 j 个元素，由于(1,2)与(2,1)算重复的子集，所以我们可以规定枚举的顺序，
     // 枚举的下一个下标一定大于当前下标，这样就实现了去重，
     // 例如，枚举了[1,2]，在枚举[2]时，就只能枚举[2,3]
     // 这里的体现就是每次 j 从 i开始枚举而不从头开始枚举
    for (int j = i; j < nums.length; j++) {
        // 第 i 个答案选第 j 个元素
        path.add(nums[j]);
        // 遍历第 i+1 个答案
        dfs(j+ 1, nums, ans, path);
        // 回滚
        path.removeLast();
   }
 }
```

