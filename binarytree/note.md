# 二叉树

## 递归二叉树（2025-12-31）

* 递归：将原问题不断分为子问题，体现了递，这样不断划分下去，总有一个尽头，这个尽头就是边界条件，在达到边界条件后，返回结果的过程体现了归。
* 二叉树的递归遍历，一开始不要陷入细节，而是考虑整个树和左右子树的关系，抓住递；然后再考虑递的尽头，边界条件，以及达到边界条件后返回结果的归的过程。
* 答案通常就在二叉树递的过程或者归的过程产生（一些题目提供了两种解法）。
* 二叉树最小深度于最大深度的区别在于：对于**非叶节点**，如果一个儿子是空节点，另一个儿子不是空节点，那么**答案只能来自非空的那一侧**。而最大深度的逻辑一定会选非空一侧，而最小深度则会选空一侧，所以要通过代码逻辑来避免这种情况。
* 将二叉树的递归遍历解题步骤通常划分为：递、归、记录答案，三个过程。
* 如果判断当前节点是否符合答案的逻辑时，需要用到父节点的信息，这个信息可以从全局变量获取，也可以在递的过程传递下来。
* 在二叉树的垂序遍历过程中，用到了map相关知识点，这里总结复习一下：
  * 要想 map 的按键排序，用实现类 treemap
  * 对于集合指定规则的排序用 comparator 比较器中指定
  * map.computeIfAbsent 的用法：如果 key 存在，直接返回value，否则传入key，计算返回 value 最终返回 value

## 二叉树 相同、对称、平衡、右视图（2026-1-1）

基础题目：100.相同的树、101.对称二叉树、110.平衡二叉树、119.二叉树的右视图

扩展题目：965、954、226、617、2331、508、1026、1372、1080

心得体会：
* 首先今天最强烈的感觉就是二叉树的递归遍历本质上是访问每一个节点，在访问的过程中对节点做处理，而子问题的拆分，其实是在提取公共逻辑部分的代码。
* 在访问当前节点的方法中调用自身来访问子节点，就能实现递归遍历，而且这种遍历没有遗漏
* 有时题目比较复杂，可以将递归遍历中的逻辑简化，通过返回值、全局变量记录必要的数据，递归结束后再处理答案的逻辑。
* 复习了 map.merge 的用法：key 不存在直接建立 （key，newValue），key 存在，将 oldValue 与 newValue 一同传入函数，返回值作为新值
* 在 1026.节点与其祖先之间的最大差值一题中体会到了自顶向下的递与自底向上的归的过程。
* 加深了我对“递”与“归”的理解：递是一个分解问题的过程，归是更关注整体的关系
* 自顶向下：有点类似先序遍历，先对当前节点做逻辑处理，再向下传递
* 自底向上：则类似后序遍历，先到最下面，再向上归，再根据左子树的情况和右子树的情况得到本树的情况
* 具体选用哪种方法，我认为要看你的答案怎么产生，或者说需要什么信息，如果需要向下传递的信息，例如路径和，直观的方法就是向下传递，但是也可以向上归时减去当前节点的值，也能实现。但是有的信息则需要特定的其中一种，又或者将两者结合，这就是难题了。
* 自顶向下更符合人类思维，但若要学好后面的动态规划，必须掌握自底向上的思考方式。
* 1372.二叉树中的最长交错路径让我体会到了递归过程重置变量
* 递归只有在处理（递下去）的问题时，才可以转化为迭代。处理（归上来）问题时，是无法转化为迭代的。
* 1080. 根到叶路径上的不足节点题中我充分体会到了递与归，首先递的是从上到该节点的路径和，归的是包含该节点的从根到叶的路径总和，将这两个信息都记录下来，中间的逻辑就是判断该节点是否是不足节点需要删除的逻辑了。

## 二叉树的先序、中序、后序遍历（2026-1-2）

基础题目：98. 验证二叉搜索树

扩展题目：700.二叉搜索树中的搜索 、938.二叉搜索树的范围和、530.二叉搜索树的最小绝对差、2476.二叉搜索树最近节点查询

心得体会：

验证二叉搜索树，可以通过下面三种遍历顺序来实现，能够很好的体会到各自的区别：
* 先序遍历：在某些情况下可以不用递归子树，从这个角度来说，先序遍历最快
* 中序遍历：对于二叉搜索树来说，中序遍历出来的结果是严格递增的，需要用到这个递增序列时，通常选用中序
* 后序遍历：最通用的，无论如何都会遍历整个树，自底向上需要返回值

体会到这三者之间的区别后，对于不同题目选择相应的遍历顺序：
* 700. 二叉搜索树中的搜索：先序遍历很有优势：当前值等于 target 直接就返回当前节点了，不用往下递归
* 938. 二叉搜索树的范围和：先序结合归的思想：当前值在 low 与 high 之间，则返回左子树的和 + 右子树的和，否则，如果当前值大于 high 只用返回左子树的和，当前值小于 high 只用返回右子树的值。这种提前返回的很适合先序遍历。
* 530. 二叉搜索树的最小绝对差：可以利用中序遍历是严格递增的序列，则答案只会产生在相邻两个数之间。
* 2476. 二叉搜索树最近节点查询：利用中序遍历结果是递增序列实现，这道题有个根据提示信息中分析实践复杂度的技巧：首先这道题有两个思路：一个是一次遍历树，在一次遍历树的过程中循环对 queries 表判断；另一个是通过一次遍历树拿到数组，在数组中通过循环二分查找来对 queries 表来进行判断。根据提示信息，queries 表中元素的数量与树的节点数量级相同。所以在方式 1 下。是按复杂度是 O（n^2），而方式 2 下时间复杂度是 O（nlogn）显然选择方式二。

## 通过先序、中序、后序构造二叉树（2026-1-3）

基础题目：98. 验证二叉搜索树

扩展题目：501.二叉搜索树中的众数、230.二叉搜索树中第 K 小的元素、1373. 二叉搜索子树的最大键值和、105. 从前序与中序遍历序列构造二叉树、106. 从中序与后序遍历序列构造二叉树、889. 根据前序和后序遍历构造二叉树、1110. 删点成林

心得体会：
501.二叉搜索树中的众数：首先我自然而然想到的是通过一个 hashmap 来记录遍历过程中节点值出现的次数，然后再从 hashmap 中取出遍历次数最多的加入答案。但是，这种暴力做法没有用到二叉搜索树的性质，因为众数只会出现在中序遍历中连续相同的节点中，所以为了优化采用中序遍历，遍历时维护前一个值 pre，如果当前值等于 pre，则 cnt++，不相同则要将 cnt 重置为1，重新开始计数，但是这样只能找到最高频次，怎么记录答案？同时维护一个遍历到当前位置出现最多频率的 maxCnt，当 cnt == maxCnt 时记录答案，但是当 cnt > maxCnt 后要清空答案，同时更新 maxCnt，可以用到链表中或者队列中的 clear（）

230. 二叉搜索树中第 K 小的元素：显然直接使用中序遍历就可以解决这道题

1373. 二叉搜索子树的最大键值和：在遍历的同时，需要判断以当前节点为根的树是否是二叉搜索树，是的话，它的键值和。判断二叉搜索树之前用前序、中序、后序分别实现了，这里还要用到键值和，很自然的想到用后序遍历，将是二叉搜索树的键值和返回回来，然后记录答案，这里需要注意特殊情况的处理：负数时，返回零，因为空的树是任意树的子树，也算二叉搜索树，其“最大和”为0

105. 从前序与中序遍历序列构造二叉树（重点）：一开始拿到这道题有些无从下手，在纸上演算很好实现构造，但是用程序来编写就无从下手了。通过查看题解，才学到了这题的解法：根据前序遍历得到当前根节点，在再中序序列中找当前根节点的位置，前面的就是该节点的左子树，后面的就是该节点的右子树，这样就将原问题转化为了在子数组中构造二叉树（这其实和手写做题步骤类似，不断确定根节点以及其左右子树）。这道题的优化就是可以设置一个 hash 表来快速找到先序序列中当前遍历的节点在中序序列中的位置。


106. 从中序与后序遍历序列构造二叉树：和 105 题类似了，加深了我将纸上的解法转化为程序解法的理解

889. 根据前序和后序遍历构造二叉树：这道题的变化就是确定了根节点之后，无法确定迭代的下一个根节点是谁，同时也无法根据根节点将数组分为左右子树。但是由于答案要求满足条件即可，我们可以规定，先序序列中 1 位置的节点就是 0 节点的左子树，基于此来构造迭代。这里需要一个判定，先序序列中的 1 是否存在，也就是当前节点是否是叶子节点，不是的话 1 就肯定存在，反之则不存在。

1110. 删点成林：这道题就是明显的后序遍历解决：先序如果删了当前节点，左右子树找不到了，中序右子树找不到了，后序遍历：左右子树都删除完成后，判断当前节点是否需要删除，是的话，将左右加入答案。

### 总结：

今天的题目总体难度不低，主要是对二叉树的先序中序后序遍历的一个巩固，其中**从前序与中序遍历序列构造二叉树**这道题是重点，其实这类题目只要思路清晰，写起来是十分通常的。在具体实现递归时一定要会“抓大放小”：不要转细节的牛角尖，先把握整体，什么时候递什么时候归，以及边界条件是什么，这些弄清楚了，细节部分自然而然就出来了。还有就是一般题目中给了二叉搜索树的条件，通常就是要中序遍历，不然随便一颗普通的树遍历也能实现，题目还给二叉搜索树不是多余吗？



