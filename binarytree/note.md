# 二叉树

## 递归二叉树（2025-12-31）

* 递归：将原问题不断分为子问题，体现了递，这样不断划分下去，总有一个尽头，这个尽头就是边界条件，在达到边界条件后，返回结果的过程体现了归。
* 二叉树的递归遍历，一开始不要陷入细节，而是考虑整个树和左右子树的关系，抓住递；然后再考虑递的尽头，边界条件，以及达到边界条件后返回结果的归的过程。
* 答案通常就在二叉树递的过程或者归的过程产生（一些题目提供了两种解法）。
* 二叉树最小深度于最大深度的区别在于：对于**非叶节点**，如果一个儿子是空节点，另一个儿子不是空节点，那么**答案只能来自非空的那一侧**。而最大深度的逻辑一定会选非空一侧，而最小深度则会选空一侧，所以要通过代码逻辑来避免这种情况。
* 将二叉树的递归遍历解题步骤通常划分为：递、归、记录答案，三个过程。
* 如果判断当前节点是否符合答案的逻辑时，需要用到父节点的信息，这个信息可以从全局变量获取，也可以在递的过程传递下来。
* 在二叉树的垂序遍历过程中，用到了map相关知识点，这里总结复习一下：
  * 要想 map 的按键排序，用实现类 treemap
  * 对于集合指定规则的排序用 comparator 比较器中指定
  * map.computeIfAbsent 的用法：如果 key 存在，直接返回value，否则传入key，计算返回 value 最终返回 value

## 二叉树 相同、对称、平衡、右视图（2026-1-1）

基础题目：100.相同的树、101.对称二叉树、110.平衡二叉树、119.二叉树的右视图

扩展题目：965、954、226、617、2331、508、1026、1372、1080

心得体会：
* 首先今天最强烈的感觉就是二叉树的递归遍历本质上是访问每一个节点，在访问的过程中对节点做处理，而子问题的拆分，其实是在提取公共逻辑部分的代码。
* 在访问当前节点的方法中调用自身来访问子节点，就能实现递归遍历，而且这种遍历没有遗漏
* 有时题目比较复杂，可以将递归遍历中的逻辑简化，通过返回值、全局变量记录必要的数据，递归结束后再处理答案的逻辑。
* 复习了 map.merge 的用法：key 不存在直接建立 （key，newValue），key 存在，将 oldValue 与 newValue 一同传入函数，返回值作为新值
* 在 1026.节点与其祖先之间的最大差值一题中体会到了自顶向下的递与自底向上的归的过程。
* 加深了我对“递”与“归”的理解：递是一个分解问题的过程，归是更关注整体的关系
* 自顶向下：有点类似先序遍历，先对当前节点做逻辑处理，再向下传递
* 自底向上：则类似后序遍历，先到最下面，再向上归，再根据左子树的情况和右子树的情况得到本树的情况
* 具体选用哪种方法，我认为要看你的答案怎么产生，或者说需要什么信息，如果需要向下传递的信息，例如路径和，直观的方法就是向下传递，但是也可以向上归时减去当前节点的值，也能实现。但是有的信息则需要特定的其中一种，又或者将两者结合，这就是难题了。
* 自顶向下更符合人类思维，但若要学好后面的动态规划，必须掌握自底向上的思考方式。
* 1372.二叉树中的最长交错路径让我体会到了递归过程重置变量
* 递归只有在处理（递下去）的问题时，才可以转化为迭代。处理（归上来）问题时，是无法转化为迭代的。
* 1080. 根到叶路径上的不足节点题中我充分体会到了递与归，首先递的是从上到该节点的路径和，归的是包含该节点的从根到叶的路径总和，将这两个信息都记录下来，中间的逻辑就是判断该节点是否是不足节点需要删除的逻辑了。

## 二叉树的先序、中序、后序遍历（2026-1-2）

基础题目：98. 验证二叉搜索树

扩展题目：700.二叉搜索树中的搜索 、938.二叉搜索树的范围和、530.二叉搜索树的最小绝对差、2476.二叉搜索树最近节点查询

心得体会：

验证二叉搜索树，可以通过下面三种遍历顺序来实现，能够很好的体会到各自的区别：
* 先序遍历：在某些情况下可以不用递归子树，从这个角度来说，先序遍历最快
* 中序遍历：对于二叉搜索树来说，中序遍历出来的结果是严格递增的，需要用到这个递增序列时，通常选用中序
* 后序遍历：最通用的，无论如何都会遍历整个树，自底向上需要返回值

体会到这三者之间的区别后，对于不同题目选择相应的遍历顺序：
* 700. 二叉搜索树中的搜索：先序遍历很有优势：当前值等于 target 直接就返回当前节点了，不用往下递归
* 938. 二叉搜索树的范围和：先序结合归的思想：当前值在 low 与 high 之间，则返回左子树的和 + 右子树的和，否则，如果当前值大于 high 只用返回左子树的和，当前值小于 high 只用返回右子树的值。这种提前返回的很适合先序遍历。
* 530. 二叉搜索树的最小绝对差：可以利用中序遍历是严格递增的序列，则答案只会产生在相邻两个数之间。
* 2476. 二叉搜索树最近节点查询：利用中序遍历结果是递增序列实现，这道题有个根据提示信息中分析实践复杂度的技巧：首先这道题有两个思路：一个是一次遍历树，在一次遍历树的过程中循环对 queries 表判断；另一个是通过一次遍历树拿到数组，在数组中通过循环二分查找来对 queries 表来进行判断。根据提示信息，queries 表中元素的数量与树的节点数量级相同。所以在方式 1 下。是按复杂度是 O（n^2），而方式 2 下时间复杂度是 O（nlogn）显然选择方式二。

