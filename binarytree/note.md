# 二叉树

## 递归二叉树（2025-12-31）

* 递归：将原问题不断分为子问题，体现了递，这样不断划分下去，总有一个尽头，这个尽头就是边界条件，在达到边界条件后，返回结果的过程体现了归。
* 二叉树的递归遍历，一开始不要陷入细节，而是考虑整个树和左右子树的关系，抓住递；然后再考虑递的尽头，边界条件，以及达到边界条件后返回结果的归的过程。
* 答案通常就在二叉树递的过程或者归的过程产生（一些题目提供了两种解法）。
* 二叉树最小深度于最大深度的区别在于：对于**非叶节点**，如果一个儿子是空节点，另一个儿子不是空节点，那么**答案只能来自非空的那一侧**。而最大深度的逻辑一定会选非空一侧，而最小深度则会选空一侧，所以要通过代码逻辑来避免这种情况。
* 将二叉树的递归遍历解题步骤通常划分为：递、归、记录答案，三个过程。
* 如果判断当前节点是否符合答案的逻辑时，需要用到父节点的信息，这个信息可以从全局变量获取，也可以在递的过程传递下来。
* 在二叉树的垂序遍历过程中，用到了map相关知识点，这里总结复习一下：
  * 要想 map 的按键排序，用实现类 treemap
  * 对于集合指定规则的排序用 comparator 比较器中指定
  * map.computeIfAbsent 的用法：如果 key 存在，直接返回value，否则传入key，计算返回 value 最终返回 value

## 二叉树 相同、对称、平衡、右视图（2026-1-1）

基础题目：100.相同的树、101.对称二叉树、110.平衡二叉树、119.二叉树的右视图

扩展题目：965、954、226、617、2331、508、1026、1372、1080

心得体会：
* 首先今天最强烈的感觉就是二叉树的递归遍历本质上是访问每一个节点，在访问的过程中对节点做处理，而子问题的拆分，其实是在提取公共逻辑部分的代码。
* 在访问当前节点的方法中调用自身来访问子节点，就能实现递归遍历，而且这种遍历没有遗漏
* 有时题目比较复杂，可以将递归遍历中的逻辑简化，通过返回值、全局变量记录必要的数据，递归结束后再处理答案的逻辑。
* 复习了 map.merge 的用法：key 不存在直接建立 （key，newValue），key 存在，将 oldValue 与 newValue 一同传入函数，返回值作为新值
* 在 1026.节点与其祖先之间的最大差值一题中体会到了自顶向下的递与自底向上的归的过程。
* 加深了我对“递”与“归”的理解：递是一个分解问题的过程，归是更关注整体的关系
* 自顶向下：有点类似先序遍历，先对当前节点做逻辑处理，再向下传递
* 自底向上：则类似后序遍历，先到最下面，再向上归，再根据左子树的情况和右子树的情况得到本树的情况
* 具体选用哪种方法，我认为要看你的答案怎么产生，或者说需要什么信息，如果需要向下传递的信息，例如路径和，直观的方法就是向下传递，但是也可以向上归时减去当前节点的值，也能实现。但是有的信息则需要特定的其中一种，又或者将两者结合，这就是难题了。
* 自顶向下更符合人类思维，但若要学好后面的动态规划，必须掌握自底向上的思考方式。
* 1372.二叉树中的最长交错路径让我体会到了递归过程重置变量
* 递归只有在处理（递下去）的问题时，才可以转化为迭代。处理（归上来）问题时，是无法转化为迭代的。
* 1080. 根到叶路径上的不足节点题中我充分体会到了递与归，首先递的是从上到该节点的路径和，归的是包含该节点的从根到叶的路径总和，将这两个信息都记录下来，中间的逻辑就是判断该节点是否是不足节点需要删除的逻辑了。

## 二叉树的先序、中序、后序遍历（2026-1-2）

基础题目：98. 验证二叉搜索树

扩展题目：700.二叉搜索树中的搜索 、938.二叉搜索树的范围和、530.二叉搜索树的最小绝对差、2476.二叉搜索树最近节点查询

心得体会：

验证二叉搜索树，可以通过下面三种遍历顺序来实现，能够很好的体会到各自的区别：
* 先序遍历：在某些情况下可以不用递归子树，从这个角度来说，先序遍历最快
* 中序遍历：对于二叉搜索树来说，中序遍历出来的结果是严格递增的，需要用到这个递增序列时，通常选用中序
* 后序遍历：最通用的，无论如何都会遍历整个树，自底向上需要返回值

体会到这三者之间的区别后，对于不同题目选择相应的遍历顺序：
* 700. 二叉搜索树中的搜索：先序遍历很有优势：当前值等于 target 直接就返回当前节点了，不用往下递归
* 938. 二叉搜索树的范围和：先序结合归的思想：当前值在 low 与 high 之间，则返回左子树的和 + 右子树的和，否则，如果当前值大于 high 只用返回左子树的和，当前值小于 high 只用返回右子树的值。这种提前返回的很适合先序遍历。
* 530. 二叉搜索树的最小绝对差：可以利用中序遍历是严格递增的序列，则答案只会产生在相邻两个数之间。
* 2476. 二叉搜索树最近节点查询：利用中序遍历结果是递增序列实现，这道题有个根据提示信息中分析实践复杂度的技巧：首先这道题有两个思路：一个是一次遍历树，在一次遍历树的过程中循环对 queries 表判断；另一个是通过一次遍历树拿到数组，在数组中通过循环二分查找来对 queries 表来进行判断。根据提示信息，queries 表中元素的数量与树的节点数量级相同。所以在方式 1 下。是按复杂度是 O（n^2），而方式 2 下时间复杂度是 O（nlogn）显然选择方式二。

## 通过先序、中序、后序构造二叉树（2026-1-3）

基础题目：98. 验证二叉搜索树

扩展题目：501.二叉搜索树中的众数、230.二叉搜索树中第 K 小的元素、1373. 二叉搜索子树的最大键值和、105. 从前序与中序遍历序列构造二叉树、106. 从中序与后序遍历序列构造二叉树、889. 根据前序和后序遍历构造二叉树、1110. 删点成林

心得体会：
501.二叉搜索树中的众数：首先我自然而然想到的是通过一个 hashmap 来记录遍历过程中节点值出现的次数，然后再从 hashmap 中取出遍历次数最多的加入答案。但是，这种暴力做法没有用到二叉搜索树的性质，因为众数只会出现在中序遍历中连续相同的节点中，所以为了优化采用中序遍历，遍历时维护前一个值 pre，如果当前值等于 pre，则 cnt++，不相同则要将 cnt 重置为1，重新开始计数，但是这样只能找到最高频次，怎么记录答案？同时维护一个遍历到当前位置出现最多频率的 maxCnt，当 cnt == maxCnt 时记录答案，但是当 cnt > maxCnt 后要清空答案，同时更新 maxCnt，可以用到链表中或者队列中的 clear（）

230. 二叉搜索树中第 K 小的元素：显然直接使用中序遍历就可以解决这道题

1373. 二叉搜索子树的最大键值和：在遍历的同时，需要判断以当前节点为根的树是否是二叉搜索树，是的话，它的键值和。判断二叉搜索树之前用前序、中序、后序分别实现了，这里还要用到键值和，很自然的想到用后序遍历，将是二叉搜索树的键值和返回回来，然后记录答案，这里需要注意特殊情况的处理：负数时，返回零，因为空的树是任意树的子树，也算二叉搜索树，其“最大和”为0

105. 从前序与中序遍历序列构造二叉树（重点）：一开始拿到这道题有些无从下手，在纸上演算很好实现构造，但是用程序来编写就无从下手了。通过查看题解，才学到了这题的解法：根据前序遍历得到当前根节点，在再中序序列中找当前根节点的位置，前面的就是该节点的左子树，后面的就是该节点的右子树，这样就将原问题转化为了在子数组中构造二叉树（这其实和手写做题步骤类似，不断确定根节点以及其左右子树）。这道题的优化就是可以设置一个 hash 表来快速找到先序序列中当前遍历的节点在中序序列中的位置。


106. 从中序与后序遍历序列构造二叉树：和 105 题类似了，加深了我将纸上的解法转化为程序解法的理解

889. 根据前序和后序遍历构造二叉树：这道题的变化就是确定了根节点之后，无法确定迭代的下一个根节点是谁，同时也无法根据根节点将数组分为左右子树。但是由于答案要求满足条件即可，我们可以规定，先序序列中 1 位置的节点就是 0 节点的左子树，基于此来构造迭代。这里需要一个判定，先序序列中的 1 是否存在，也就是当前节点是否是叶子节点，不是的话 1 就肯定存在，反之则不存在。

1110. 删点成林：这道题就是明显的后序遍历解决：先序如果删了当前节点，左右子树找不到了，中序右子树找不到了，后序遍历：左右子树都删除完成后，判断当前节点是否需要删除，是的话，将左右加入答案。

### 总结：

今天的题目总体难度不低，主要是对二叉树的先序中序后序遍历的一个巩固，其中**从前序与中序遍历序列构造二叉树**这道题是重点，其实这类题目只要思路清晰，写起来是十分通常的。在具体实现递归时一定要会“抓大放小”：不要转细节的牛角尖，先把握整体，什么时候递什么时候归，以及边界条件是什么，这些弄清楚了，细节部分自然而然就出来了。还有就是一般题目中给了二叉搜索树的条件，通常就是要中序遍历，不然随便一颗普通的树遍历也能实现，题目还给二叉搜索树不是多余吗？

## 二叉树的最近公共祖先

基础题目：236. 二叉树的最近公共祖先

扩展题目：235.二叉搜索树的最近公共祖先、1123.所有最深叶节点的最近公共祖先

心得体会：

236 的解题思路与我们找最近公共祖先类似：找到 p、q 节点，找到 p、q 后向上看父节点，最近的共同父节点就是答案。

具体实现时分类讨论：当前节点是 q 或 p，直接返回当前节点，不往下看了，如果其父节点的兄弟子树中没有找到 p、q说明当前节点就是最近公共祖先，同样如果是空也返回当前节点，即空；如果当前节点的左右子树中都各自找到了 p、q 说明当前节点就是最近公共祖先，直接返回

235 在 236 的基础上可以优化，如果当前节点的值比 p、q的值都大，由于二叉树的性质，说明在右子树中，反之在左子树中，其他情况的话就是在左右子树中，直接返回当前节点

1123 这道题首先我的思路是找到树中最深的节点，保存在 List 当中，然后再利用 236 中的思路解题，也就是需要两次遍历树。在看了题解后，优化为了一次遍历，分别有两种实现思路：

* 思路1：自顶向下：向下递的时候需要传递当前节点的深度，向上归的时候需要返回最大深度，中间的逻辑就是当当前节点的左子树的最大深度等于右子树的最大深度且等于全局最大深度时，这时候当前节点就是答案（答案不断变化的，但是最后一定是基于最深的叶子节点建立的，这要求遍历的时候维护全局最大深度）
* 思路2：自底向上：也就是遍历完拿到子树的信息后，再做逻辑处理，基于思路1，可以发现自底向上需要的子树信息：子树的最大深度，子树的最深叶子节点的最近公共祖先。如果左子树的深度大于右子树的深度，lca 是左子树的 lca，如果右子树的深度大于左子树，则 lca 是右子树的，如果相等，lca 就是当前节点，最后返回当前子树的深度与当前节点的 lca。

Pair 数据结构：在 1123 中的自底向上实现中，函数返回值需要子树深度，以及子树的最深叶子节点两种类型的，首先我想到了map，但是由于两个数据没有 key 到 value 的一个映射关系，更像是一个二元组（深度，节点），要做到左右随取，且左右有位置关系，所以用到 pair 数据结构，用来表示有位置关系的二元组。

### 总结

1123 又一次的让我体会到了递与归的过程，非常经典。用我看到的一条评论当作今天的结束：

递归设计两大原则


1. 向下传递 - 函数参数传递法

- 适用场景：从根节点向叶子节点传递信息，如节点深度、路径状态等。

- 实现方式：在递归函数参数中携带信息，如  dfs(node, depth)  ，递归调用时更新参数值，如  dfs(node.left, depth + 1)  。

- 特点：父节点状态顺流至子节点，子节点无法反向影响父节点。

2. 向上返回 - 返回值回溯法

- 适用场景：从叶子节点向根节点汇总信息，像子树高度、最深叶子最近公共祖先等。

- 实现方式：利用递归函数返回值传递结果，如  return max_depth  。

- 特点：子节点计算结果逆向传递给父节点，父节点依左右子树返回值确定自身返回值。

## 二叉树的层序遍历（2026-1-5）

基础题目：102.二叉树的层序遍历、103.二叉树的锯齿形层序遍历、513.找树左下角的值

扩展题目：107、104、111、2583、199、116、117、1302、1609、2415、2641

心得体会：

* 使用二叉树的层序遍历时，通常题目中有一层一层的字眼
* 最基础的实现是一个数组存储当前层，一个数组存储下一层，当前层遍历的同时，添加子节点到下一层，遍历结束后，将当前层设置为下一层
* 进一步优化层序遍历：通过队列实现，维护局部遍历队列的长度表示当前层的节点个数，类似的也是遍历当前层节点时，添加子节点到队列，注意遍历一个节点需要将它出队
* 2415.反转二叉树的奇数层：有一个小trick，题目要求的反转奇数层节点，可以通过反转奇数层节点的值来实现，不用该节点的左右子节点。

补充：在完成题目时，对 java 集合方面的知识进行了补充：

* List.of(...) 与 new ArrayList<>()：List.of() 创建的是不可变 list，不能增删改，适合只读，但是指向它的引用是可以更改的；new ArrayList<>() 创建的是可变集合。常见用法：`List<Integer> a = new ArrayList<>(List.of(1,2,3));`
* Collections.reverse(list) 与 list.reversed：前者就地反转，修改原 list；后者返回倒序视图 view，不改原 list，O(1) 创建视图
* Queue.offer 与 add，poll 与 remove：offer 失败返回 false，poll 空队列返回 null；而 add 与 remove 会抛异常，`offer + poll`（不用异常控制流）更常用


### 总结

层序遍历思路总的来说较为简单，但是由于它需要我们显示维护一个队列，通过对队列入队出队处理来模拟递归栈，所以代码相对较为复杂。需要对同一层的节点处理时，常常利用层序遍历。
