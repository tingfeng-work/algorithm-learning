# 链表

## 反转链表（2025-12-29）

三个指针：pre、cur、next
循环结束条件 cur == null
循环结束后，pre 表示新链表头部，cur 指向空

反转链表扩展时，在需要对头节点进行处理时会引入哨兵节点来简化逻辑，通常哨兵节点指向头节点，这是一个不变量，在返回答案需要头节点时，可以返回 dummy.next 这个不变量。

在修改节点的 next 的时，通常需要记录原来的 next，否则修改后就找不到原来的 next 了。

反转链表非常有用，在需要倒着遍历链表时，例如判断回文串等等，反转链表可以实现题目的简化。

需要注意的是：这里实现的反转链表不会断开原链表，例如对 1->2->3->4->5 从 3 开始反转会得到，1->2->3<-4<-5，也可以分开来看 head1->1->2->3, head2->5->4->3


## 快慢指针（2025-12-29）

快慢指针应用在链表上的优势在于链表不能索引读取。在寻找中间节点的例子中，通过快慢指针，可以很好的定位中间节点，本质上运用了距离差来实现。

快慢指针也可以很好的应用在环形链表的相关题目，因为存在环的话快慢指针最终会相遇。

中间节点的确定也有很多应用，因为无法像数组一样直接定位中间节点，所以高效的（一次遍历）确定中间节点是很有必要的。

## 删除链表中的元素（2025-12-30）

在链表中删除元素的关键在于找到要删除元素的前一个节点 node，通过 node.next = node.next.next 来删除目标节点。

在做题过程中遇到了一些特殊处理：

* 删除倒数第 N 个节点：通过前后指针之间的距离固定为 N 来找到倒数第 N 个节点的前一个节点
* 删除排序链表中的重复元素：通过循环删除来删除全部重复元素，这其中需要注意的是需要访问 node.next 或 node.val 时一定要确保 node 不为空
* 从链表中移除在数组中存在的节点：用到了 HashSet 来快速判断遍历到的节点的值是否在数组中出现
* 从链表中移除该节点右边存在比该节点值大的节点的节点时，正向实现了 O（n^2）的算法，但是超时了，这时为了优化想到了正难则反，对链表取反，条件转化为删除比当前节点值小的节点，否则移动当前节点，最终实现了 O（n）时间复杂度的算法。