# 动态规划

## 从回溯到记忆化搜索到递推（2026-1-11）

基础题目：198.打家劫舍

扩展题目：70.爬楼梯、746.使用最小花费爬楼梯、3693.爬楼梯Ⅱ、213.打家劫舍Ⅱ

### 概述

什么是动态规划？从回溯到记忆化搜索再到递推来探索这个问题的答案。

从打家劫舍的例子中体会这个逐步递进的过程：首先从最后一个元素开始枚举（方便后面衔接动态规划），有选或不选两个选择，`dfs（i）`表示前 i 个元素的最大金额，则 `dfs（i） = Math.max(dfs(i - 1), dfs(i - 2) + nums[i])` 。但是这样会有大量重复计算，如图 `dfs(2)`计算了两次，`dfs(1)`计算了三次

![1](assets/1.png)

记忆化搜索：优化回溯的计算过程，将之前计算过的返回值 dfs(i) 保存，每次递归计算前判断之前是否计算过，计算过直接返回结果。

```java
private int dfs(int i, int[] nums, int[] cache) {
        if (i < 0) {
            return 0;
       }
        if (cache[i] != -1)
          return cache[i];
       cache[i] = Math.max(dfs(i - 1, nums, cache), dfs(i - 2, nums, cache) + nums[i]);
       return cache[i];
   }
```

递推：记忆化搜索用到了递归以及额外的空间保存 `dfs(i)` 的结果，能否对空间复杂度进行优化？答案是可以的，在递归遍历树的时候，我们清楚的知道节点 2 的返回值，也就是 `dfs(2)` 来自 `dfs(1)`与`dfs(0)`，同样`dfs(3)` 来自 `dfs(2)`与`dfs(1)`，所以可以直接从自顶向上转变为自底向上的递推，简单说，就是先计算  `dfs(1)`与`dfs(0)`，然后递推到 `dfs(2)`，以此类推计算到 `dfs(i)`，怎么理解这里的递推？其实就是 `dfs`时省略的递的过程，直接归。这样做的好处是：将递归转化为循环，避免了递归栈的额外空间开销。

从记忆化搜索到递推：

* 状态数组（dp 数组）记录 dfs 的返回结果
* 循环代替递归
* 状态数组的初始化代替递归边界条件

回过来看怎么理解递推？就是从先前的状态递推到下一个状态，当前状态不仅仅与当前元素有关，还与之前的元素有关，因为当前状态来自与之前的状态，而之前状态受之前元素的影响。以打家劫舍为例，打劫第 2 个房子后的最大金额 由 打劫第 1 个房子后的最大金额 与 打劫第 0 个房子后的最大金额决定，这就是递推公式。这个例子中由于当前状态只需要之前的两个状态，所以可以进一步将空间复杂度优化为 O（1）



### 结合具体题目

70.爬楼梯：爬到当前 i 阶的爬法，由 i-1阶的爬法 + i-2阶的爬法决定，这个就是递推公式，状态的初始化第一阶有一种爬法，第零阶也有一种爬法（或者第二阶有两种爬法），循环需要遍历 n 个状态，最终返回状态 n

746.使用最小花费爬楼梯：由题意花费 cost[i] 可以选择向上爬一或两个台阶，所以当前状态由前一个状态和前前状态决定，递推公式得到了，状态的初始化可以从 0 阶或 1 阶开始，前两个状态为 0，需要遍历 n 个状态，最终返回状态 n

3693.爬楼梯 Ⅱ：就是爬楼梯的变形，由题意一次可以跳 1、2、3 阶台阶，所以当前状态是由前三个状态决定的

213.打家劫舍 Ⅱ：同样，也是打家劫舍的变形




### 心得体会

* 动态规划体现了 dfs 中的归，省略递的过程直接归，将其转化为递推，当前状态由之前的状态决定，这就体现了动态，即状态是变化的。
* 当递推关系或者初始状态想不清楚时，可以回到回溯+记忆化搜索，再将其翻译为递推。
* 解题时，当题目中的当前状态受之前状态的影响，准确的说当前状态是在之前状态的基础上得来，就可以使用动态规划。

## 从回溯到记忆化搜索到递推巩固练习（2026-1-12）

基础题目：198.打家劫舍

扩展题目：740.删除并获得点数、2466.统计构造好字符串的方案数、377.组合总和、2266.统计打字方案数、64.最小路径和

### 概述

今天的题目是打家劫舍、爬楼梯这些基础题型的变形题，通过今天的学习对打家劫舍与爬楼梯这类题有了更深刻的体会。

### 结合具体题目

740.删除并获得点数：每次操作选择任意一个 nums[i] 将它与所有nums[i]+-1一同删除，并获得 nums[i]的点数，返回最大点数。这道题是打家劫舍的变形：考虑将所有值相同的 nums[i] 归为一类，也就是创建一个值域数组 sums，sums[j] 表示在 nums 中所有值 j 的数的和，例如 nums = [2,2,3,3,3,4], sums=[0,0,4,9,4]，现在就相当于在 sums 中选择一个元素，相邻元素就不能选择了，转化为了打家劫舍。

2466.统计构造好字符串的方案数：这道题其实是爬楼梯的变形题，每次可以爬 zero 或 one 阶，求爬 low 到 high 阶楼梯的方案总数

377.组合总和Ⅳ：给你一个由不同整数组成的数组 nums ，和一个目标整数 target 。请你从 nums 中找出并返回总和为 target 的元素组合的个数（不同顺序算不同的组合）。本质也是爬楼梯，相当于爬 target 阶，每次可以上 nums[i] 阶楼梯，求方案数。

2266.统计打字方案数：题目较为复杂，就不叙述了，可以在 leetcode 上参考原题。本质上是分组+爬楼梯，按照不同 target 分组，最后的方案数是各组的方案数相乘。

 64.最小路径和：这道题不是变形题，它是动归经典题型，当前状态取决于左状态与上状态。

### 心得体会

打家劫舍本质在于约束条件是选了一个元素，其相邻元素都不可以选了。 740.删除并获得节点数，选择一个节点，删除该节点值相邻的元素，所以联想到打家劫舍，没有打家劫舍的条件，就构造打家劫舍的条件：值域数组。

爬楼梯的本质是一个排列问题，也就是顺序不同属于不同的方案，例如先迈1步再迈2步与先迈2步再迈1步是不同的，这让爬楼梯适配很多题型：字符串长度一定、和一定，这种定值可以看作目标台阶数量 target，而每次可以选择不同数量的元素来构造答案，相当于一次可以选择爬不同数量的阶梯数。
